<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>è´ªåƒè›‡ - å•æœº/è”æœºå¯¹æˆ˜</title>
  <style>
    * { 
      margin: 0; padding: 0; box-sizing: border-box;
      font-family: "Microsoft YaHei", Arial, sans-serif;
    }
    body { 
      display: flex; flex-direction: column; align-items: center;
      background: #1a1a1a; color: #fff; padding: 20px;
      min-height: 100vh;
    }
    h1 { margin-bottom: 15px; color: #4CAF50; }
    #gameCanvas { 
      border: 2px solid #444; background: #000; border-radius: 4px;
      max-width: 100%; height: auto;
    }
    .controls {
      margin: 15px 0; display: flex; gap: 10px; flex-wrap: wrap;
      justify-content: center;
    }
    button {
      padding: 10px 20px; border: none; border-radius: 6px;
      background: #2196F3; color: white; cursor: pointer;
      font-size: 16px; transition: all 0.2s;
    }
    button:hover { background: #1976D2; transform: translateY(-1px); }
    button:disabled {
      background: #666; cursor: not-allowed; transform: none;
    }
    .info-panel {
      width: 800px; max-width: 100%;
      display: flex; justify-content: space-between; align-items: center;
      margin: 10px 0; padding: 8px 15px;
      background: #2d2d2d; border-radius: 4px;
    }
    #scoreBoard { font-size: 18px; font-weight: bold; }
    #modeTip { color: #ccc; font-size: 14px; }
    /* ç§»åŠ¨ç«¯æ–¹å‘é”® */
    .mobile-controls {
      display: none; grid-template-columns: repeat(3, 1fr);
      gap: 10px; margin-top: 15px; width: 300px;
    }
    .mobile-btn { padding: 20px; font-size: 24px; }
    @media (max-width: 820px) {
      .info-panel { flex-direction: column; gap: 5px; text-align: center; }
      .mobile-controls { display: grid; }
    }
  </style>
</head>
<body>
  <h1>ğŸ è´ªåƒè›‡å¯¹æˆ˜</h1>
  
  <div class="info-panel">
    <div id="scoreBoard">åˆ†æ•°ï¼š0 | AIåˆ†æ•°ï¼š0</div>
    <div id="modeTip">è¯·é€‰æ‹©æ¸¸æˆæ¨¡å¼</div>
  </div>

  <div class="controls">
    <button id="singleMode">å•æœºæ¨¡å¼ï¼ˆVS AIï¼‰</button>
    <button id="onlineMode">è”æœºæ¨¡å¼ï¼ˆVS ç©å®¶ï¼‰</button>
    <button id="resetBtn" disabled>é‡ç½®æ¸¸æˆ</button>
  </div>

  <canvas id="gameCanvas" width="800" height="600"></canvas>

  <!-- ç§»åŠ¨ç«¯æ–¹å‘æ§åˆ¶ -->
  <div class="mobile-controls">
    <button class="mobile-btn" onclick="mobileDir('up')">â†‘</button>
    <button class="mobile-btn" onclick="mobileDir('left')">â†</button>
    <button class="mobile-btn" onclick="mobileDir('right')">â†’</button>
    <button class="mobile-btn" onclick="mobileDir('down')">â†“</button>
  </div>

  <script>
    // ===================== åŸºç¡€é…ç½® =====================
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const gridSize = 20;
    const canvasWidth = 800;
    const canvasHeight = 600;

    // æ ¸å¿ƒçŠ¶æ€
    let gameMode = ''; // single / online
    let ws = null;     // WebSocketè¿æ¥
    let gameLoop = null;

    // ===================== å•æœºæ¨¡å¼å˜é‡ =====================
    let playerSnake = [{ x: 200, y: 200 }];
    let aiSnake = [{ x: 600, y: 200 }];
    let playerDir = 'right';
    let aiDir = 'left';
    let singleFood = generateFood([playerSnake, aiSnake]);
    let playerScore = 0;
    let aiScore = 0;

    // ===================== è”æœºæ¨¡å¼é…ç½® =====================
    let localPlayerId = '';
    let onlinePlayers = new Map();
    let onlineFood = {};
    // ğŸ”´ æ›¿æ¢ä¸ºä½ çš„å…¬ç½‘WSSåœ°å€ï¼ˆéƒ¨ç½²åä¿®æ”¹ï¼‰
    // æœ¬åœ°æµ‹è¯•ç”¨ï¼šws://localhost:8080
    // å…¬ç½‘ç”¨ï¼šwss://ä½ çš„renderæœåŠ¡å™¨åœ°å€.onrender.com
    const WSS_URL = 'ws://localhost:8080'; 

    // ===================== å·¥å…·å‡½æ•° =====================
    function generateFood(snakes = []) {
      let x, y;
      do {
        x = Math.floor(Math.random() * (canvasWidth / gridSize)) * gridSize;
        y = Math.floor(Math.random() * (canvasHeight / gridSize)) * gridSize;
      } while (snakes.some(snake => snake.some(seg => seg.x === x && seg.y === y)));
      return { x, y };
    }

    function drawSnake(snake, color) {
      if (!snake || !snake.length) return;
      ctx.fillStyle = color;
      snake.forEach((seg, idx) => {
        if (idx === 0) { // å¤´éƒ¨åŠ ç™½è¾¹
          ctx.strokeStyle = '#fff';
          ctx.lineWidth = 2;
          ctx.strokeRect(seg.x, seg.y, gridSize, gridSize);
        }
        ctx.fillRect(seg.x, seg.y, gridSize, gridSize);
      });
    }

    function drawFood(food) {
      if (!food) return;
      ctx.fillStyle = '#ff0000';
      ctx.beginPath();
      ctx.arc(food.x + gridSize/2, food.y + gridSize/2, gridSize/2 - 2, 0, Math.PI * 2);
      ctx.fill();
    }

    function clearCanvas() {
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, canvasWidth, canvasHeight);
    }

    // ===================== å•æœºæ¨¡å¼é€»è¾‘ =====================
    function aiMove() {
      const head = aiSnake[0];
      // AIè¿½é£Ÿç‰©é€»è¾‘
      if (head.x < singleFood.x && aiDir !== 'left') aiDir = 'right';
      else if (head.x > singleFood.x && aiDir !== 'right') aiDir = 'left';
      else if (head.y < singleFood.y && aiDir !== 'up') aiDir = 'down';
      else if (head.y > singleFood.y && aiDir !== 'down') aiDir = 'up';

      // ç§»åŠ¨AIå¤´éƒ¨
      const newHead = { ...head };
      switch (aiDir) {
        case 'up': newHead.y -= gridSize; break;
        case 'down': newHead.y += gridSize; break;
        case 'left': newHead.x -= gridSize; break;
        case 'right': newHead.x += gridSize; break;
      }

      // ç©¿å¢™
      if (newHead.x < 0) newHead.x = canvasWidth - gridSize;
      if (newHead.x >= canvasWidth) newHead.x = 0;
      if (newHead.y < 0) newHead.y = canvasHeight - gridSize;
      if (newHead.y >= canvasHeight) newHead.y = 0;

      aiSnake.unshift(newHead);

      // AIåƒé£Ÿç‰©
      if (newHead.x === singleFood.x && newHead.y === singleFood.y) {
        aiScore += 10;
        singleFood = generateFood([playerSnake, aiSnake]);
      } else {
        aiSnake.pop();
      }

      // AIè‡ªèº«ç¢°æ’
      for (let i = 1; i < aiSnake.length; i++) {
        if (newHead.x === aiSnake[i].x && newHead.y === aiSnake[i].y) {
          aiSnake = [{ x: 600, y: 200 }];
          aiDir = 'left';
          aiScore = 0;
          break;
        }
      }

      // AIæ’ç©å®¶
      for (let seg of playerSnake) {
        if (newHead.x === seg.x && newHead.y === seg.y) {
          aiSnake = [{ x: 600, y: 200 }];
          aiDir = 'left';
          aiScore = 0;
          playerSnake = [{ x: 200, y: 200 }];
          playerDir = 'right';
          playerScore = 0;
          singleFood = generateFood([playerSnake, aiSnake]);
          break;
        }
      }
    }

    function singlePlayerLoop() {
      clearCanvas();

      // ç§»åŠ¨ç©å®¶è›‡
      const head = playerSnake[0];
      const newHead = { ...head };
      switch (playerDir) {
        case 'up': newHead.y -= gridSize; break;
        case 'down': newHead.y += gridSize; break;
        case 'left': newHead.x -= gridSize; break;
        case 'right': newHead.x += gridSize; break;
      }

      // ç©¿å¢™
      if (newHead.x < 0) newHead.x = canvasWidth - gridSize;
      if (newHead.x >= canvasWidth) newHead.x = 0;
      if (newHead.y < 0) newHead.y = canvasHeight - gridSize;
      if (newHead.y >= canvasHeight) newHead.y = 0;

      playerSnake.unshift(newHead);

      // ç©å®¶åƒé£Ÿç‰©
      if (newHead.x === singleFood.x && newHead.y === singleFood.y) {
        playerScore += 10;
        singleFood = generateFood([playerSnake, aiSnake]);
      } else {
        playerSnake.pop();
      }

      // ç©å®¶è‡ªèº«ç¢°æ’
      for (let i = 1; i < playerSnake.length; i++) {
        if (newHead.x === playerSnake[i].x && newHead.y === playerSnake[i].y) {
          playerSnake = [{ x: 200, y: 200 }];
          playerDir = 'right';
          playerScore = 0;
          break;
        }
      }

      // AIç§»åŠ¨
      aiMove();

      // ç»˜åˆ¶å…ƒç´ 
      drawFood(singleFood);
      drawSnake(playerSnake, '#2196F3'); // ç©å®¶è“
      drawSnake(aiSnake, '#f44336');    // AIçº¢

      // æ›´æ–°åˆ†æ•°
      document.getElementById('scoreBoard').textContent = `åˆ†æ•°ï¼š${playerScore} | AIåˆ†æ•°ï¼š${aiScore}`;

      gameLoop = requestAnimationFrame(singlePlayerLoop);
    }

    // ===================== è”æœºæ¨¡å¼é€»è¾‘ =====================
    function initOnlineMode() {
      // å…³é—­å·²æœ‰è¿æ¥
      if (ws) ws.close();

      ws = new WebSocket(WSS_URL);
      ws.onopen = () => {
        document.getElementById('modeTip').textContent = 'è”æœºæ¨¡å¼ - ç­‰å¾…å…¶ä»–ç©å®¶...';
        console.log('âœ… è”æœºè¿æ¥æˆåŠŸ');
      };

      ws.onmessage = (event) => {
        const data = JSON.parse(event.data);
        switch (data.type) {
          case 'init':
            localPlayerId = data.playerId;
            onlineFood = data.food;
            data.players.forEach(p => onlinePlayers.set(p.id, p));
            document.getElementById('modeTip').textContent = `è”æœºæ¨¡å¼ - ä½ çš„IDï¼š${localPlayerId} | åœ¨çº¿ï¼š${data.onlineCount}`;
            break;

          case 'gameState':
            onlineFood = data.food;
            data.players.forEach(p => onlinePlayers.set(p.id, p));
            // ç»˜åˆ¶è”æœºæ¸¸æˆ
            clearCanvas();
            drawFood(onlineFood);
            data.players.forEach(player => {
              drawSnake(player.snake, player.color);
              // ç»˜åˆ¶ç©å®¶åˆ†æ•°
              ctx.fillStyle = player.color;
              ctx.font = '16px Arial';
              ctx.fillText(`ç©å®¶${player.id}ï¼š${player.score}`, 10 + (player.id - 1) * 120, 20);
            });
            // æ›´æ–°åˆ†æ•°é¢æ¿ï¼ˆæ˜¾ç¤ºæœ¬åœ°ç©å®¶åˆ†æ•°ï¼‰
            const localPlayer = onlinePlayers.get(localPlayerId);
            if (localPlayer) {
              document.getElementById('scoreBoard').textContent = `ä½ çš„åˆ†æ•°ï¼š${localPlayer.score} | åœ¨çº¿äººæ•°ï¼š${data.players.length}`;
            }
            break;

          case 'playerJoin':
            onlinePlayers.set(data.player.id, data.player);
            document.getElementById('modeTip').textContent = `è”æœºæ¨¡å¼ - ç©å®¶${data.player.id}åŠ å…¥ | åœ¨çº¿ï¼š${data.onlineCount}`;
            break;

          case 'playerLeave':
            onlinePlayers.delete(data.playerId);
            document.getElementById('modeTip').textContent = `è”æœºæ¨¡å¼ - ç©å®¶${data.playerId}ç¦»å¼€ | åœ¨çº¿ï¼š${data.onlineCount}`;
            break;
        }
      };

      ws.onclose = () => {
        document.getElementById('modeTip').textContent = 'è”æœºæ¨¡å¼ - è¿æ¥æ–­å¼€';
        stopGame();
      };

      ws.onerror = (err) => {
        console.error('âŒ è”æœºè¿æ¥å¤±è´¥ï¼š', err);
        document.getElementById('modeTip').textContent = 'è”æœºæ¨¡å¼ - è¿æ¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥æœåŠ¡å™¨';
        stopGame();
      };
    }

    // ===================== é€šç”¨æ§åˆ¶ =====================
    function stopGame() {
      // åœæ­¢æ¸¸æˆå¾ªç¯
      if (gameLoop) cancelAnimationFrame(gameLoop);
      // å…³é—­WebSocket
      if (ws) ws.close();
      // é‡ç½®çŠ¶æ€
      playerSnake = [{ x: 200, y: 200 }];
      aiSnake = [{ x: 600, y: 200 }];
      playerDir = 'right';
      aiDir = 'left';
      playerScore = 0;
      aiScore = 0;
      singleFood = generateFood();
      onlinePlayers.clear();
      localPlayerId = '';
      // é‡ç½®UI
      clearCanvas();
      document.getElementById('scoreBoard').textContent = 'åˆ†æ•°ï¼š0 | AIåˆ†æ•°ï¼š0';
      document.getElementById('modeTip').textContent = 'è¯·é€‰æ‹©æ¸¸æˆæ¨¡å¼';
      document.getElementById('resetBtn').disabled = true;
      document.getElementById('singleMode').disabled = false;
      document.getElementById('onlineMode').disabled = false;
    }

    // æ–¹å‘æ§åˆ¶ï¼ˆé”®ç›˜+ç§»åŠ¨ç«¯ï¼‰
    function changeDir(newDir) {
      const oppositeMap = { up: 'down', down: 'up', left: 'right', right: 'left' };
      // å•æœºæ¨¡å¼
      if (gameMode === 'single' && newDir !== oppositeMap[playerDir]) {
        playerDir = newDir;
      }
      // è”æœºæ¨¡å¼
      if (gameMode === 'online' && ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: 'direction', direction: newDir }));
      }
    }

    // ç§»åŠ¨ç«¯æ–¹å‘æ§åˆ¶
    function mobileDir(dir) {
      changeDir(dir);
    }

    // é”®ç›˜æ–¹å‘é”®æ§åˆ¶
    document.addEventListener('keydown', (e) => {
      switch (e.key) {
        case 'ArrowUp': changeDir('up'); break;
        case 'ArrowDown': changeDir('down'); break;
        case 'ArrowLeft': changeDir('left'); break;
        case 'ArrowRight': changeDir('right'); break;
      }
    });

    // æŒ‰é’®äº‹ä»¶ç»‘å®š
    document.getElementById('singleMode').addEventListener('click', () => {
      stopGame();
      gameMode = 'single';
      document.getElementById('modeTip').textContent = 'å•æœºæ¨¡å¼ - æ–¹å‘é”®æ§åˆ¶ï¼ŒVS AI';
      document.getElementById('singleMode').disabled = true;
      document.getElementById('onlineMode').disabled = true;
      document.getElementById('resetBtn').disabled = false;
      singlePlayerLoop();
    });

    document.getElementById('onlineMode').addEventListener('click', () => {
      stopGame();
      gameMode = 'online';
      document.getElementById('singleMode').disabled = true;
      document.getElementById('onlineMode').disabled = true;
      document.getElementById('resetBtn').disabled = false;
      initOnlineMode();
    });

    document.getElementById('resetBtn').addEventListener('click', stopGame);
  </script>
</body>
</html>